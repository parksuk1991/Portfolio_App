# -*- coding: utf-8 -*-
"""APP_repository.ipynb

generated by Colab.
"""

# Enhanced app.py with data gap filling functionality
import streamlit as st
import yfinance as yf
import numpy as np
import pandas as pd
from datetime import datetime
import datetime as dt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
from scipy.stats import pearsonr
import warnings
warnings.filterwarnings('ignore')


# 페이지 설정
st.set_page_config(
    page_title="Portfolio Backtesting App",
    page_icon="📈",
    layout="wide",
    initial_sidebar_state="expanded"
)

# 벤치마크 이름 매핑
BENCHMARK_NAMES = {
    'SPY': 'S&P 500 지수',
    'QQQ': 'Nasdaq 100 지수',
    'ACWI': 'MSCI ACWI 지수'
}

# 벤치마크 옵션 (표시용)
BENCHMARK_OPTIONS = {
    'S&P 500 지수': 'SPY',
    'Nasdaq 100 지수': 'QQQ',
    'MSCI ACWI 지수': 'ACWI'
}

# 유사 자산 매핑 (새로운 ETF -> 과거에 존재했던 유사 자산)
SIMILAR_ASSETS_MAP = {
    # 섹터 ETF 매핑
    'XLC': ['XTL', 'IYZ', 'VNQ'],  # Communication Services -> Telecom/Tech/REITs
    'XLY': ['RTH', 'XRT', 'VCR'],  # Consumer Discretionary -> Retail
    'XLP': ['VDC', 'PBJ', 'SZK'],  # Consumer Staples
    'XLE': ['VDE', 'IYE', 'DIG'],  # Energy
    'XLF': ['VFH', 'IYF', 'KBE'],  # Financials
    'XLV': ['VHT', 'IYH', 'PJP'],  # Healthcare
    'XLI': ['VIS', 'IYJ', 'PPA'],  # Industrials
    'XLB': ['VAW', 'IYM', 'SLX'],  # Materials
    'XLK': ['VGT', 'IYW', 'QQQ'],  # Technology
    'XLU': ['VPU', 'IDU', 'PUI'],  # Utilities

    # 스타일 ETF 매핑
    'SPYV': ['IVE', 'VTV', 'DVY'],  # S&P 500 Value
    'SPYG': ['IVW', 'VUG', 'MGK'],  # S&P 500 Growth
    'VYM': ['DVY', 'VTV', 'SCHD'],  # High Dividend Yield
    'RSP': ['EQL', 'EWRS', 'SPY'],  # Equal Weight S&P 500
    'USMV': ['SPLV', 'EFAV', 'SPY'],  # Low Volatility
    'SPMO': ['MTUM', 'PDP', 'QQQ'],  # Momentum

    # 국제 ETF 매핑
    'IDEV': ['EFA', 'VEA', 'ACWX'],  # Developed Markets
    'IEMG': ['EEM', 'VWO', 'SCHE'],  # Emerging Markets
}

# 대체 자산 풀 (역사가 긴 자산들)
FALLBACK_ASSETS = {
    'large_cap_growth': ['QQQ', 'VUG', 'IVW'],
    'large_cap_value': ['VTV', 'IVE', 'DVY'],
    'small_cap': ['IWM', 'VB', 'IJR'],
    'international_dev': ['EFA', 'VEA', 'ACWX'],
    'international_em': ['EEM', 'VWO', 'DEM'],
    'sectors': ['XLK', 'XLF', 'XLV', 'XLE', 'XLI'],
    'broad_market': ['SPY', 'VTI', 'ITOT']
}

def get_asset_classification(ticker):
        return 'broad_market'

def find_best_substitute(target_ticker, available_data, start_date, end_date, min_correlation=0.7):
    return best_candidate, best_data

def fill_missing_data(tickers, start_date, end_date, fill_gaps=True):
        return None, {}

# 캐시된 데이터 로더 - 수정된 버전
@st.cache_data
def load_universe_data_enhanced(tickers, start_date, end_date, fill_gaps=True):
    """향상된 유니버스 데이터 로더"""
    return fill_missing_data(tickers, start_date, end_date, fill_gaps)

@st.cache_data
def load_benchmark_data(ticker, start_date, end_date):
        return None

def adjust_weights_to_bounds(weights, upper_bound, lower_bound, max_iterations=100):
    return adjusted_weights

def run_backtest(stock_returns, window, top_n_stocks, upper_bound, lower_bound):
    return pd.Series(portfolio_returns, index=portfolio_dates), weights_composition

def safe_convert_to_float(value):
    """값을 안전하게 float로 변환"""
    try:
        if hasattr(value, 'item'):
            return float(value.item())
        elif hasattr(value, '__array__') and value.ndim == 0:
            return float(value)
        else:
            return float(value)
    except (ValueError, TypeError, AttributeError):
        return 0.0

def calculate_performance_metrics(returns):
    }

def get_rebalancing_changes(current_weights, previous_weights):
    return changes

# 메인 앱
def main():
    st.title("📈 Portfolio Backtesting App")
    st.markdown("##### 만든이: 박석")
    

    st.markdown(
        '<div style="text-align: right; margin-bottom: 10px;">'
        'Data 출처: <a href="https://finance.yahoo.com/" target="_blank">Yahoo Finance</a>'
        '</div>',
        unsafe_allow_html=True
    )

    # 앱 설명 섹션 - 업데이트
    st.markdown("### 📋 앱 소개")
    st.markdown("""
    **이 앱은 데이터 공백 자동 보완 기능을 갖춘 모멘텀 기반 포트폴리오 백테스팅 도구입니다.**

    #### 🎯 주요 기능
    - **자산 선택**: 원하는 ETF, 주식 등 자유로운 투자 유니버스 설정
    - **파라미터 조정**: 모멘텀 기간, 선택 종목 수, 최대/최소 가중치 등 전략 파라미터 조정
    - **기간 설정**: 백테스팅 분석 기간을 자유롭게 설정 가능
    - **모멘텀 전략**: 과거 수익률을 기반으로 상위 자산을 선별하여 포트폴리오를 구성
    - **리스크 조정**: 역변동성 가중치와 모멘텀 스코어를 결합한 스마트 포트폴리오 최적화
    - **월별 리밸런싱**: 매월 포트폴리오를 재조정하여 최적의 자산 구성 유지

    #### ✔️ 분석 결과 제공
    - **성과 지표**: 수익률, 변동성, 샤프 비율, 최대 낙폭 등 주요 투자 지표 분석
    - **벤치마크 비교**: S&P 500, Nasdaq 100, MSCI ACWI 지수와의 성과 비교
    - **시각화**: 누적 수익률, 리스크 분석, 포트폴리오 구성 변화 등 다양한 차트 제공

    #### 🔧 데이터 공백 보완 방식
    - **유사 자산 매핑**: 선택한 자산의 과거 데이터가 부족한 경우, 유사한 특성을 가진 대체 자산으로 자동 보완
    - **상관관계 분석**: 기존 포트폴리오와 높은 상관관계를 가진 대체 자산 선택
    - **자산 분류별 대체**: 성장주, 가치주, 섹터별 등 자산 특성에 따른 체계적 대체
    """)

    st.markdown("---")

    # 사이드바 설정
    st.sidebar.header("📊 유니버스 설정")

    # 기본 티커 목록
    default_tickers = [
        'XLC', 'XLY', 'XLP', 'XLE', 'XLF', 'XLV', 'XLI', 'XLB', 'XLK', 'XLU',
        'SPYV', 'SPYG', 'VYM', 'RSP', 'USMV', 'SPMO', 'SPY', 'QQQ', 'IDEV', 'IEMG', 'ACWI'
    ]

    tickers_input = st.sidebar.text_area(
        "종목 티커 (쉼표로 구분)",
        value=", ".join(default_tickers[:25]),
        help="예시: SPY, QQQ, XLK",
        height=70
    )

    tickers = [ticker.strip().upper() for ticker in tickers_input.split(",") if ticker.strip()]

    # 데이터 공백 보완 옵션 추가
    fill_gaps = st.sidebar.checkbox(
        "데이터 공백 보완 옵션",
        value=True,
        help="자산의 과거 데이터가 부족한 경우, 유사한 자산으로 자동 대체"
    )

    # 날짜 설정 - 간격 조정

    st.markdown("""
        <style>
        /* date input 라벨 크기 줄이기 */
        .stDateInput label {
            font-size: 13.5px !important;
        }
        /* 달력 내부 텍스트 크기 줄이기 */
        .stDateInput input {
            font-size: 13.5px !important;
        }
        </style>
    """, unsafe_allow_html=True)
    st.sidebar.markdown('<div style="margin-top: 15px;"></div>', unsafe_allow_html=True)
    
    col1, col2 = st.sidebar.columns(2)
    with col1:
        start_date = st.date_input(
            "시작 날짜",
            value=dt.date(2010, 1, 1),
            min_value=dt.date(2005, 1, 1),
            max_value=dt.date.today()
        )
    
    with col2:
        end_date = st.date_input(
            "종료 날짜",
            value=dt.date.today(),
            min_value=start_date,
            max_value=dt.date.today()
        )

    # 백테스팅 파라미터
    st.sidebar.markdown('<div style="margin-top: 10px;"></div>', unsafe_allow_html=True)
    st.sidebar.subheader("백테스팅 설정")

    window = st.sidebar.slider("모멘텀 윈도우 (개월)", 3, 12, 6)
    top_n_stocks = st.sidebar.slider("선택 종목 수", 5, min(25, len(tickers)), min(15, len(tickers)))
    upper_bound = st.sidebar.slider("최대 가중치 (%)", 5, 20, 20) / 100
    lower_bound = st.sidebar.slider("최소 가중치 (%)", 1, 5, 1) / 100

    benchmark_display = st.sidebar.selectbox(
        "벤치마크",
        list(BENCHMARK_OPTIONS.keys()),
        index=2
    )
    benchmark_ticker = BENCHMARK_OPTIONS[benchmark_display]

    # 실행 버튼
    if st.sidebar.button("🚀 포트폴리오 생성", type="primary"):
        if len(tickers) < 5:
            st.error("최소 5개 이상의 티커를 입력해주세요.")
            return

        try:
            with st.spinner("데이터 로딩 및 전처리 중..."):
                # 향상된 데이터 로더 사용
                monthly_df, substitution_log = load_universe_data_enhanced(
                    tickers, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'), fill_gaps
                )

                if monthly_df is None:
                    st.error("데이터 로드에 실패했습니다.")
                    return

                # 대체 로그 표시
                if substitution_log:
                    st.subheader("🔄 데이터 대체 로그")
                    substitute_df = pd.DataFrame([
                        {
                            '원본 자산': original,
                            '대체 자산': info['substitute'],
                            '대체 시작일': info['substitute_start'].strftime('%Y-%m-%d') if info['substitute_start'] else 'N/A',
                            '대체 방식': '유사자산' if info['method'] == 'similar_asset' else '기타'
                        }
                        for original, info in substitution_log.items()
                    ])
                    st.dataframe(substitute_df, use_container_width=True, hide_index=True)

                # 벤치마크 데이터 로드
                benchmark_data = load_benchmark_data(
                    benchmark_ticker, start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d')
                )

                if benchmark_data is None:
                    st.error("벤치마크 데이터 로드에 실패했습니다.")
                    return

                if isinstance(benchmark_data, pd.Series):
                    benchmark_df = benchmark_data
                elif isinstance(benchmark_data, pd.DataFrame):
                    benchmark_df = benchmark_data.iloc[:, 0]
                else:
                    st.error(f"예상치 못한 벤치마크 데이터 타입: {type(benchmark_data)}")
                    return

                # 공통 기간 조정
                common_start = max(monthly_df.index[0], benchmark_df.index[0])
                common_end = min(monthly_df.index[-1], benchmark_df.index[-1])

                monthly_df = monthly_df.loc[common_start:common_end]
                benchmark_df = benchmark_df.loc[common_start:common_end]

                stock_returns = monthly_df.pct_change().dropna()
                benchmark_returns = benchmark_df.pct_change().dropna()

                # 디버깅 정보
                st.write(f"자산 데이터 길이: {len(stock_returns)}")
                st.write(f"벤치마크 데이터 길이: {len(benchmark_returns)}")
                st.write(f"벤치마크 데이터 타입: {type(benchmark_returns)}")

            with st.spinner("백테스팅 실행 중..."):
                # 백테스팅 실행
                portfolio_returns, weights_composition = run_backtest(
                    stock_returns, window, top_n_stocks, upper_bound, lower_bound
                )

                # 포트폴리오와 벤치마크의 공통 인덱스 찾기
                common_index = portfolio_returns.index.intersection(benchmark_returns.index)

                # 공통 인덱스로 재정렬
                portfolio_returns_aligned = portfolio_returns.loc[common_index]
                benchmark_returns_aligned = benchmark_returns.loc[common_index]

                # 디버깅 정보 출력
                #st.write(f"포트폴리오 수익률 데이터 포인트: {len(portfolio_returns_aligned)}")
                #st.write(f"벤치마크 수익률 데이터 포인트: {len(benchmark_returns_aligned)}")
                #st.write(f"공통 기간: {common_index[0].strftime('%Y-%m-%d')} ~ {common_index[-1].strftime('%Y-%m-%d')}")

                # 성과 지표 계산
                portfolio_metrics = calculate_performance_metrics(portfolio_returns_aligned)
                benchmark_metrics = calculate_performance_metrics(benchmark_returns_aligned)

            # 결과 표시
            st.success(f"백테스팅 및 포트폴리오 생성 완료! ({common_index[0].strftime('%Y-%m')} ~ {common_index[-1].strftime('%Y-%m')})")

            # 성과 지표 테이블
            col1, col2 = st.columns(2)

            with col1:
                st.subheader("📊 포트폴리오 성과")
                benchmark_name = BENCHMARK_NAMES.get(benchmark_ticker, benchmark_ticker)

                # 안전한 포맷팅 (이제 모든 값이 float이므로 안전함)
                metrics_df = pd.DataFrame({
                    '포트폴리오': [
                        f"{portfolio_metrics['total_return']:.2%}",
                        f"{portfolio_metrics['annualized_return']:.2%}",
                        f"{portfolio_metrics['volatility']:.2%}",
                        f"{portfolio_metrics['sharpe_ratio']:.2f}",
                        f"{portfolio_metrics['max_drawdown']:.2%}"
                    ],
                    f'{benchmark_name}': [
                        f"{benchmark_metrics['total_return']:.2%}",
                        f"{benchmark_metrics['annualized_return']:.2%}",
                        f"{benchmark_metrics['volatility']:.2%}",
                        f"{benchmark_metrics['sharpe_ratio']:.2f}",
                        f"{benchmark_metrics['max_drawdown']:.2%}"
                    ]
                }, index=['총 수익률', '연평균 수익률', '연변동성', '샤프 비율', '최대 낙폭'])

                st.dataframe(metrics_df, use_container_width=True)

            with col2:
                st.subheader("📋 백테스팅 정보")
                info_df = pd.DataFrame({
                    '항목': ['분석 기간', '총 종목 수', '선택 종목 수', '리밸런싱', '가중치 범위'],
                    '값': [
                        f"{common_index[0].strftime('%Y-%m')} ~ {common_index[-1].strftime('%Y-%m')}",
                        f"{len(tickers)}개",
                        f"{top_n_stocks}개",
                        "매월",
                        f"{lower_bound:.1%} ~ {upper_bound:.1%}"
                    ]
                })
                st.dataframe(info_df, use_container_width=True, hide_index=True)

            # 최근 포트폴리오 구성과 리밸런싱 정보
            st.subheader(f"📰 포트폴리오 업데이트 ({dt.date.today().strftime('%Y-%m')} 기준)")

            if weights_composition:
                # 최근 두 개 날짜 가져오기
                recent_dates = sorted(weights_composition.keys())
                latest_date = recent_dates[-1]
                previous_date = recent_dates[-2] if len(recent_dates) > 1 else None

                current_weights = weights_composition[latest_date]
                previous_weights = weights_composition[previous_date] if previous_date else None

                col1, col2 = st.columns(2)

                with col1:
                    # 현재 포트폴리오 구성
                    st.write(f"**📕{latest_date.strftime('%Y-%m-%d')} 리밸런싱 안**")

                    current_df = pd.DataFrame([
                        {'종목': stock, '비중': f"{weight:.2%}"}
                        for stock, weight in sorted(current_weights.items(), key=lambda x: x[1], reverse=True)
                    ])
                    st.dataframe(current_df, use_container_width=True, hide_index=True)

                    # 파이 차트
                    fig_pie = px.pie(
                        values=list(current_weights.values()),
                        names=list(current_weights.keys()),
                        title="📒현재 비중 분포"
                    )
                    fig_pie.update_layout(template="plotly_dark", height=400)
                    st.plotly_chart(fig_pie, use_container_width=True)

                with col2:
                    # 리밸런싱 변화
                    if previous_weights:
                        st.write(f"**📙전월 대비 리밸런싱 변화** ({previous_date.strftime('%Y-%m-%d')} → {latest_date.strftime('%Y-%m-%d')})")

                        changes = get_rebalancing_changes(current_weights, previous_weights)

                        if changes:
                            rebalancing_data = []
                            for stock, change_info in sorted(changes.items(), key=lambda x: abs(x[1]['change']), reverse=True):
                                action_emoji = "📈" if change_info['action'] == 'INCREASE' else "📉" if change_info['action'] == 'DECREASE' else "➡️"
                                rebalancing_data.append({
                                    '종목': f"{action_emoji} {stock}",
                                    '이전 비중': f"{change_info['previous']:.2%}",
                                    '현재 비중': f"{change_info['current']:.2%}",
                                    '변화': f"{change_info['change']:+.2%}"
                                })

                            rebalancing_df = pd.DataFrame(rebalancing_data)
                            st.dataframe(rebalancing_df, use_container_width=True, hide_index=True)

                            # 리밸런싱 변화 시각화
                            stocks = list(changes.keys())
                            changes_values = [changes[stock]['change'] for stock in stocks]
                            colors = ['green' if x > 0 else 'red' for x in changes_values]

                            fig_rebal = go.Figure(data=[
                                go.Bar(x=stocks, y=[x*100 for x in changes_values],
                                      marker_color=colors,
                                      text=[f"{x:+.1%}" for x in changes_values],
                                      textposition='auto')
                            ])
                            fig_rebal.update_layout(
                                title="📗리밸런싱 변화 (%p)",
                                xaxis_title="종목",
                                yaxis_title="비중 변화 (%p)",
                                template="plotly_dark",
                                height=400
                            )
                            st.plotly_chart(fig_rebal, use_container_width=True)
                        else:
                            st.info("이전 월 대비 유의미한 리밸런싱 변화가 없습니다.")
                    else:
                        st.info("비교할 이전 포트폴리오 데이터가 없습니다.")

            # 차트 생성 - 수정된 부분
            st.subheader("📈 성과 분석")
            benchmark_name = BENCHMARK_NAMES.get(benchmark_ticker, benchmark_ticker)

            # 데이터 유효성 검증
            st.write("=== 시각화 데이터 검증 ===")
            st.write(f"포트폴리오 수익률 샘플: {portfolio_returns_aligned.head(3).values}")
            st.write(f"벤치마크 수익률 샘플: {benchmark_returns_aligned.head(3).values}")
            st.write(f"포트폴리오 수익률 NaN 개수: {portfolio_returns_aligned.isna().sum()}")
            st.write(f"벤치마크 수익률 NaN 개수: {benchmark_returns_aligned.isna().sum()}")

            # 누적 수익률
            cumulative_portfolio = (1 + portfolio_returns_aligned).cumprod() - 1
            cumulative_benchmark = (1 + benchmark_returns_aligned).cumprod() - 1

            fig1 = go.Figure()
            fig1.add_trace(go.Scatter(
                x=cumulative_portfolio.index,
                y=cumulative_portfolio * 100,
                mode='lines',
                name='포트폴리오',
                line=dict(color='deeppink', width=2)
            ))
            fig1.add_trace(go.Scatter(
                x=cumulative_benchmark.index,
                y=cumulative_benchmark * 100,
                mode='lines',
                name=benchmark_name,
                line=dict(color='royalblue', width=2, dash='dash')
            ))
            fig1.update_layout(
                title="누적 수익률 비교",
                xaxis_title="날짜",
                yaxis_title="누적 수익률 (%)",
                hovermode='x unified',
                template="plotly_dark"
            )
            st.plotly_chart(fig1, use_container_width=True)

            # 4개 차트를 2x2로 배치
            col1, col2 = st.columns(2)

            with col1:
                # 월별 수익률 분포
                fig2 = go.Figure()
                fig2.add_trace(go.Histogram(
                    x=portfolio_returns_aligned * 100,
                    name='포트폴리오',
                    opacity=0.7,
                    marker_color='deeppink',
                    nbinsx=20
                ))
                fig2.add_trace(go.Histogram(
                    x=benchmark_returns_aligned * 100,
                    name=benchmark_name,
                    opacity=0.7,
                    marker_color='royalblue',
                    nbinsx=20
                ))
                fig2.update_layout(
                    title="월별 수익률 분포",
                    xaxis_title="월별 수익률 (%)",
                    yaxis_title="빈도",
                    barmode='overlay',
                    template="plotly_dark"
                )
                st.plotly_chart(fig2, use_container_width=True)

            with col2:
                # 롤링 샤프 비율 (12개월)
                rolling_sharpe_portfolio = portfolio_returns_aligned.rolling(12).mean() / portfolio_returns_aligned.rolling(12).std() * np.sqrt(12)
                rolling_sharpe_benchmark = benchmark_returns_aligned.rolling(12).mean() / benchmark_returns_aligned.rolling(12).std() * np.sqrt(12)

                fig3 = go.Figure()
                fig3.add_trace(go.Scatter(
                    x=rolling_sharpe_portfolio.index,
                    y=rolling_sharpe_portfolio,
                    mode='lines',
                    name='포트폴리오',
                    line=dict(color='deeppink', width=2)
                ))
                fig3.add_trace(go.Scatter(
                    x=rolling_sharpe_benchmark.index,
                    y=rolling_sharpe_benchmark,
                    mode='lines',
                    name=benchmark_name,
                    line=dict(color='royalblue', width=2, dash='dash')
                ))
                fig3.update_layout(
                    title="12개월 롤링 샤프 비율",
                    xaxis_title="날짜",
                    yaxis_title="샤프 비율",
                    hovermode='x unified',
                    template="plotly_dark"
                )
                st.plotly_chart(fig3, use_container_width=True)

            # 낙폭 비교 차트
            portfolio_cumulative = (1 + portfolio_returns_aligned).cumprod()
            portfolio_running_max = portfolio_cumulative.expanding().max()
            portfolio_drawdown = (portfolio_cumulative - portfolio_running_max) / portfolio_running_max

            benchmark_cumulative = (1 + benchmark_returns_aligned).cumprod()
            benchmark_running_max = benchmark_cumulative.expanding().max()
            benchmark_drawdown = (benchmark_cumulative - benchmark_running_max) / benchmark_running_max

            fig4 = go.Figure()
            fig4.add_trace(go.Scatter(
                x=portfolio_drawdown.index,
                y=portfolio_drawdown * 100,
                fill='tonexty',
                mode='lines',
                name='포트폴리오',
                line=dict(color='deeppink', width=1),
                fillcolor='rgba(255,20,147,0.3)'
            ))
            fig4.add_trace(go.Scatter(
                x=benchmark_drawdown.index,
                y=benchmark_drawdown * 100,
                fill='tonexty',
                mode='lines',
                name=benchmark_name,
                line=dict(color='royalblue', width=1),
                fillcolor='rgba(65,105,225,0.3)'
            ))
            fig4.update_layout(
                title="낙폭 (Drawdown) 비교",
                xaxis_title="날짜",
                yaxis_title="낙폭 (%)",
                hovermode='x unified',
                template="plotly_dark"
            )
            st.plotly_chart(fig4, use_container_width=True)

            # 포트폴리오 구성 히스토리
            st.subheader("📑 포트폴리오 구성 히스토리")

            if weights_composition:
                recent_dates = sorted(weights_composition.keys())[-5:]  # 최근 5개월

                for date_key in recent_dates:
                    weights = weights_composition[date_key]

                    with st.expander(f"{date_key.strftime('%Y-%m-%d')} 포트폴리오 구성"):
                        weights_df = pd.DataFrame([
                            {'종목': stock, '가중치': f"{weight:.2%}"}
                            for stock, weight in sorted(weights.items(), key=lambda x: x[1], reverse=True)
                        ])

                        col1, col2 = st.columns([2, 1])
                        with col1:
                            st.dataframe(weights_df, use_container_width=True, hide_index=True)

                        with col2:
                            # 파이 차트
                            fig_pie = px.pie(
                                values=list(weights.values()),
                                names=list(weights.keys()),
                                title="가중치 분포"
                            )
                            fig_pie.update_layout(template="plotly_dark", height=300)
                            st.plotly_chart(fig_pie, use_container_width=True)

        except Exception as e:
            st.error(f"백테스팅 실행 중 오류가 발생했습니다: {str(e)}")
            import traceback
            st.error(f"상세 오류: {traceback.format_exc()}")

if __name__ == "__main__":
    main()
